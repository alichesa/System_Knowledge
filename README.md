# System_Knowledge
- 用户态和内核态是Linux系统划分的状态，用户态一般是R3，内核态是R0，只有内核态才能对硬件进行操作

- 进程与线程都是并行的执行单元，进程是系统资源分配的最小单元、线程是程序运行（调度）的最小单元。多个进程之间的通信是通过系统之间进行通信的，线程通过共享内存之间进行通信，一个进程中可以又多个线程并行

- 每个线程含有自己的寄存器和局部内存（栈），然后每个线程块有个共享内存

- 查询具有TLB（快表）的话能击大加速，如果没有命中则会去再页表中寻址

- 内存交换是不同进程之间，内存覆盖是同一个程序之间

- 虚拟技术有时分复用和空分复用，时分复用可以提现在进程交替使用CPU，空分复用体现在虚拟内存的抽象

- 进程同步可以通过互斥锁、信号量、读写锁等进行同步

- 进程通信--管道通信， 消息队列， 共享内存， 信号量， 套接字

- 虚拟内存大小和物理内存大小并不是一一对应的，虚拟内存可以比物理内存大

- 读写锁就是可以同时读，若有人写则不能同时读。互斥锁就类似于排他锁。条件变量。自旋锁就是线程无法取得锁但是也不会立马放弃CPU的时间片，就是一直循环尝试获得锁

- 32和64位主要是cpu一次能处理的数据最大位宽

- 处理速度的顺序：寄存器 -> 缓存 (数据缓存和指令缓存一般分开)-> 内存 -> 硬盘

- cache的单元是cache_line，CPU从内存读取数据并不是直接读，而是一块一块地放入cache中，再读取。因此提升程序运行速度可以从提升指令缓存速度和提升数据缓存速度出发

- CPU缓存的写操作有写直达和写回两个操作，写回比较快的操作，因为它会通过标记cache里面的是否为脏数据从而进行处理

- 为了使得数据读取正确，就有了写传播和串行化两个操作，MESI就是满足这两个的协议

- L1和L2是CPU核自己独享的，L3是共享

- 中断分为硬中断和软中断，软中断一般由内核线程（操作系统所管理和执行的线程）所执行，软中断分类型，可以看哪个软中断次数多就知道系统资源占用在哪了

- 内核架构分为宏内核，微内核和混合内核，linux采用的是宏内核，意思就是说内核的操作权限更大，windows采用的是混合内核

- 虚拟内存是操作系统引入的，每个进程都有自己一套虚拟地址空间，这是单片机所没有的，单片机所指的地址是实际物理地址

- 内存分段是基于代码的作用区进行分段，会产生很多内存碎片，有内存碎片就需要进行内存交换以合并碎片，这样的效率就会很低。内存分页是指虚拟地址和实际地址通过页进行映射，一个程序运行会使用多个整页

- malloc是分配虚拟内存，当进行free的时候不会立马释放内存（brk()），而是作为缓存存在，若进程结束才会释放，但是mmap()则会立即释放。频繁使用mmap会导致缺页中断，还会会导致态切换频繁。频繁使用brk

- 虚拟内存虽然和物理内存是一一对应的关系，但是并不是所有的虚拟内存都会分配物理内存，只有进程所需要的时候才会进行分配，且还有内存回收的机制，因此虚拟内存一般都是大于物理内存的

- malloc分配的是虚拟内存，此时不会有任何操作，当进程真的需要的时候会出发缺页中断，此时才是进行分配的时候

- 内存不够时会触发内存回收，直接内存回收（同步），后台内存回收（异步），也可以分为文件页回收（干净页直接释放）和匿名页回收（触发swap机制）
