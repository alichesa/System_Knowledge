# System_Knowledge
- 在X86架构中一般有四个不同的特权级，R0 ~ R3，R0是内核态，R3是用户态，R1和R2一般是驱动程序。用户态一般使用系统调用（Syscall -- read write open 等内核函数）与内核进行交互，一般态的切换中会触发中断。系统调用一般会比普通的函数运行慢，因为它设计上下文的切换，一般是100-200个cpu周期。具体流程是：用户程序调用write() → 触发0x80中断 → CPU保存用户态寄存器 → 切换至内核栈 → 执行sys_write() → 返回用户态前恢复现场

- 用户态申请内存的流程是：应用程序调用malloc → brk/mmap触发 → 内核管理物理内存，具体实现流程 -- 检测申请内存 → 调用相应的函数 → 在进程空间创建虚拟内存区域 → 建立页表映射 → 返回虚拟地址 → 程序首次访问内存触发缺页异常，此时内核分配实际物理内存。其中mmap是大块内存（>256kb）另外一个是小内存。mmap与brk的区别就是mmap使用free会立即释放内存，而brk不会立即释放，只是先将内存标记为缓冲区。频繁使用mmap会不断触发缺页中断，这就导致上下文切换十分频繁；频繁使用brk会导致页的碎片化很严重。brk的碎片是内部碎片，主要是虚假释放的碎片，mmap的碎片是外部碎片，就是一段一段不连续是内存碎片

- 进程是系统资源分配的最小单元，每个进程都有独立的地址空间、堆栈、文件描述符等。线程是程序调度的最小单元，多个线程之间共享内存空间、全局变量等。进程创建的开销是比较大的，因为需要分配独立的资源，需要系统内核负责，也会涉及到上下文的切换，并且还需要进行内存映射，但是线程开销较小，仅设计到寄存器/栈的切换。进程之间的通信有很多 -- 管道、消息队列、共享内存、信号量、套接字。而线程之间的通信 -- 共享内存、条件变量和互斥锁、读写锁  

- 每个线程含有自己的寄存器和局部内存（栈），每个线程块有个共享内存，线程的切换必须保存所有的寄存器，寄存器是CPU组件，栈是内存组件，RSP寄存器指向栈顶

- 查询具有TLB（快表）的话能击大加速，如果没有命中则会去再页表中寻址。TLB一般在CPU缓存中，而页表一般在内存中。若查询的页表映射关系发生变化还可能发生缺页中断（所查找的资源由于其他资源需要进行了内存交换）

- 内存交换是不同进程之间，一般发生在内存不足的情况下，当被交换的内存被再次访问时就会触发缺页中断，然后又将该内存加载回来。内存覆盖是同一个程序之间，由程序员主动设计发生

- 虚拟技术的核心是通过​​资源复用​​抽象出比物理资源更多的逻辑资源，主要分为时分复用（CPU的时间片交替运行）和空分复用（多个进程使用不同的逻辑资源）

- 进程同步可以通过互斥锁、信号量、读写锁等进行同步
<img width="884" height="247" alt="image" src="https://github.com/user-attachments/assets/3370187f-a11d-4717-ada6-ddcf3250769c" />

- 读写锁 -- 允许多个线程并发读取，但只允许一个线程写，写的时候其余等待； 互斥锁 -- 同一时刻只能一个线程访问； 条件变量 -- 用于线程间的等待与通知，通常和互斥锁一起使用，实现线程间的同步； 自旋锁 -- 线程在尝试获取锁时不会被阻塞，而是持续循环尝试获取锁，适用于锁持有时间短且争用不严重的场景。

- 32和64位主要是cpu一次能处理的数据最大位宽，分别是四比特和八比特

- 处理速度的顺序：寄存器 -> 缓存 (数据缓存和指令缓存一般分开)-> 内存 -> 硬盘，栈是存储在内存中的，所以栈是不能快过寄存器的，也不能快过缓存（L1 L2 L3）   

- cache的单元是cache_line，CPU从内存读取数据并不是直接读，而是一块一块地放入cache中，再读取。因此提升程序运行速度可以从提升指令缓存速度和提升数据缓存速度出发

- CPU缓存的写操作有写直达和写回两个操作，写回是比较快的操作，因为它会通过标记cache里面的是否为脏数据从而进行处理，而写直达就是数据发生改动则立马进行写入

- 由于数据可能存在于多个缓存中（副本不同），因此需要控制数据的一致性问题 -- MESI（一致性协议）（实现了写传播（对任意缓存中的数据进行修改都会进行写的传播）与串行化（串行执行所有操作））
  | 特性        | **SMP** (对称多处理)             | **NUMA** (非统一内存访问)            |
| --------- | --------------------------- | ----------------------------- |
| **内存访问**  | 所有 CPU 共享同一内存空间             | 每个 CPU 拥有自己的本地内存，访问其他内存较慢     |
| **内存一致性** | 所有 CPU 访问相同的内存，需要缓存一致性协议    | 本地内存访问速度快，但远程内存访问有较高延迟        |
| **性能优化**  | 系统可以平等地调度 CPU 来执行任务         | 需要优化内存访问的局部性，以减少远程内存访问的延迟     |
| **扩展性**   | 限制较大，随着 CPU 数量的增加，内存访问会成为瓶颈 | 高扩展性，适合大规模系统，多 CPU 系统之间内存可以分布 |
| **适用场景**  | 小型和中型系统，适合 CPU 数量相对较少的环境    | 大规模多处理器系统，适合需要处理大量数据的场景       |


- L1和L2是CPU核的私有缓存，L3是共享缓存。如果缓存策略是写回策略，那就是写入L1 和 L2的同时标记为脏数据，后面再更新给L3和内存，但是如果是写直达，那就是直接更新给L3，多核如果同时修改L3则会发生一致性协议的修改

- 中断分为硬中断和软中断。硬中断是由硬件设备所发出的必须立马执行的中断，软中断则是程序或操作系统内核所发出可延迟处理的中断，软中断的出现说明了资源占用情况，可以通过分析软中断在不同程序阶段出现的比例从而分析出程序的性能

- 内核架构分为宏内核，微内核和混合内核，linux采用的是宏内核，意思就是说内核的操作权限更大，windows采用的是混合内核
<img width="971" height="182" alt="image" src="https://github.com/user-attachments/assets/8faf9668-f896-4f68-8e84-2397c1d37db9" />

- 内存分段是基于代码的作用区进行分段，会产生很多内存碎片（属于外部碎片）（随着程序的执行，内存中的空闲区域可能会变得零散），有内存碎片就需要进行内存交换以合并碎片，这样的效率就会很低。内存分页是指虚拟地址和实际地址通过页进行映射，一个程序运行会使用多个整页，会产生内部碎片

- 虚拟内存虽然和物理内存是一一对应的关系，但是并不是所有的虚拟内存都会分配物理内存，只有进程所需要的时候才会进行分配，且还有内存回收的机制，因此虚拟内存一般都是大于物理内存的

- 内存不够时会触发内存回收，直接内存回收（同步），后台内存回收（异步），也可以分为文件页回收（干净页直接释放）和匿名页回收（触发swap机制）

- QEMU（Quick Emulator）是一个开源的​​硬件虚拟化平台​​，允许在宿主机系统上模拟完整的虚拟计算机（包括CPU、内存、外设等）

- fork调用一次是返回两次，对于父进程是返回子进程的pid，对于子进程是返回0。fork的子进程的描述符会继承父进程的

- exec函数是将当前进程的代码、数据、堆栈等所有内存区域都替换成新的内容，从而实现进程的替换。用于加载新的可执行文件

- IO重定向原理 -- fork() + close() + open() + exec() ；文件偏移共（共享当前指针位置）享原理 -- fork() + dup()  （dup() 的作用是创建一个新的文件描述符，这个新的文件描述符和原来的文件描述符指向相同的文件，并共享文件偏移量，如果不用dup，那么就是两个进程一模一样）
<img width="960" height="220" alt="image" src="https://github.com/user-attachments/assets/8203c11f-e9ee-4de7-a443-8d17d578dd2e" />

- 内核态和用户态虽然处于同一个物理地址空间，但是其虚拟空间地址是完全分开的。线程的切换涉及到寄存器，计算器，栈顶指针，状态等切换。而进程的切换不仅设计以上，还有关于页表的切换（简称上下文的切换）

- 操作系统就是用来隔离硬件和程序的，如果没有操作系统的话，那么就不存在进程的区别，那么都作用于同一片内存，就会容易发生覆盖。操作系统内核会完成不同进程在CPU上的切换

-操作系统启动过程：从 PC 开机到加载 Boot Loader，再到加载内核并开始运行。进程创建过程：通过分配内存、设置页表、加载程序等步骤创建一个新的进程，最终将其状态设置为就绪，等待调度。进程运行过程：调度器选择一个就绪进程并切换到内核上下文，通过 forkret 初始化新进程，最后通过 trapret 切换到用户态，开始执行用户程序。  
进入系统：PC 开机 → 加载 boot loader → boot loader 加载 xv6 内核 → 内核开始运行 ； 创建一个进程： 建页表 → 分内存 → 映射地址 → 拷程序 → 设寄存器（计数器，栈顶指针等） → 就绪调度 ； 运行一个进程： 进入调度器 → 找到 RUNNABLE 进程 → 切换到内核线程上下文 → forkret 初始化 → trapret 切换到用户态


