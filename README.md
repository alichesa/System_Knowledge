# System_Knowledge
- 在X86架构中一般有四个不同的特权级，R0 ~ R3，R0是内核态，R3是用户态，R1和R2一般是驱动程序。用户态一般使用系统调用（Syscall -- read write open 等内核函数）与内核进行交互，一般态的切换中会触发中断。系统调用一般会比普通的函数运行慢，因为它设计上下文的切换，一般是100-200个cpu周期。具体流程是：用户程序调用write() → 触发0x80中断 → CPU保存用户态寄存器 → 切换至内核栈 → 执行sys_write() → 返回用户态前恢复现场

- 用户态申请内存的流程是：应用程序调用malloc → brk/mmap触发 → 内核管理物理内存，具体实现流程 -- 检测申请内存 → 调用相应的函数 → 在进程空间创建虚拟内存区域 → 建立页表映射 → 返回虚拟地址 → 程序首次访问内存触发缺页异常，此时内核分配实际物理内存。其中mmap是大块内存（>256kb）另外一个是小内存。mmap与brk的区别就是mmap使用free会立即释放内存，而brk不会立即释放，只是先将内存标记为缓冲区。频繁使用mmap会不断触发缺页中断，这就导致上下文切换十分频繁；频繁使用brk会导致页的碎片化很严重。brk的碎片是内部碎片，主要是虚假释放的碎片，mmap的碎片是外部碎片，就是一段一段不连续是内存碎片

- 进程是系统资源分配的最小单元，每个进程都有独立的地址空间、堆栈、文件描述符等。线程是程序调度的最小单元，多个线程之间共享内存空间、全局变量等。进程创建的开销是比较大的，因为需要分配独立的资源，需要系统内核负责，也会涉及到上下文的切换，并且还需要进行内存映射，但是线程开销较小，仅设计到寄存器/栈的切换。进程之间的通信有很多 -- 管道、消息队列、共享内存、信号量、套接字。而线程之间的通信 -- 共享内存、条件变量和互斥锁、读写锁  

- 每个线程含有自己的寄存器和局部内存（栈），每个线程块有个共享内存，线程的切换必须保存所有的寄存器，寄存器是CPU组件，栈是内存组件，RSP寄存器指向栈顶

- 查询具有TLB（快表）的话能击大加速，如果没有命中则会去再页表中寻址。TLB一般在CPU缓存中，而页表一般在内存中。若查询的页表映射关系发生变化还可能发生缺页中断（所查找的资源由于其他资源需要进行了内存交换）

- 内存交换是不同进程之间，一般发生在内存不足的情况下，当被交换的内存被再次访问时就会触发缺页中断，然后又将该内存加载回来。内存覆盖是同一个程序之间，由程序员主动设计发生

- 虚拟技术的核心是通过​​资源复用​​抽象出比物理资源更多的逻辑资源，主要分为时分复用（CPU的时间片交替运行）和空分复用（多个进程使用不同的逻辑资源）

- 进程同步可以通过互斥锁、信号量、读写锁等进行同步
<img width="884" height="247" alt="image" src="https://github.com/user-attachments/assets/3370187f-a11d-4717-ada6-ddcf3250769c" />

- 读写锁 -- 允许多个线程并发读取，但只允许一个线程写，写的时候其余等待； 互斥锁 -- 同一时刻只能一个线程访问； 条件变量 -- 用于线程间的等待与通知，通常和互斥锁一起使用，实现线程间的同步； 自旋锁 -- 线程在尝试获取锁时不会被阻塞，而是持续循环尝试获取锁，适用于锁持有时间短且争用不严重的场景。

- 32和64位主要是cpu一次能处理的数据最大位宽，分别是四比特和八比特

- 处理速度的顺序：寄存器 -> 缓存 (数据缓存和指令缓存一般分开)-> 内存 -> 硬盘，栈是存储在内存中的，所以栈是不能快过寄存器的，也不能快过缓存（L1 L2 L3）   

- cache的单元是cache_line，CPU从内存读取数据并不是直接读，而是一块一块地放入cache中，再读取。因此提升程序运行速度可以从提升指令缓存速度和提升数据缓存速度出发

- CPU缓存的写操作有写直达和写回两个操作，写回是比较快的操作，因为它会通过标记cache里面的是否为脏数据从而进行处理，而写直达就是数据发生改动则立马进行写入

- 由于数据可能存在于多个缓存中（副本不同），因此需要控制数据的一致性问题 -- MESI（一致性协议）（实现了写传播（对任意缓存中的数据进行修改都会进行写的传播）与串行化（串行执行所有操作））

- L1和L2是CPU核的私有缓存，L3是共享缓存。如果缓存策略是写回策略，那就是写入L1 和 L2的同时标记为脏数据，后面再更新给L3和内存，但是如果是写直达，那就是直接更新给L3，多核如果同时修改L3则会发生一致性协议的修改

- 中断分为硬中断和软中断。硬中断是由硬件设备所发出的必须立马执行的中断，软中断则是程序或操作系统内核所发出可延迟处理的中断，软中断的出现说明了资源占用情况，可以通过分析软中断在不同程序阶段出现的比例从而分析出程序的性能

- 内核架构分为宏内核，微内核和混合内核，linux采用的是宏内核，意思就是说内核的操作权限更大，windows采用的是混合内核
<img width="971" height="182" alt="image" src="https://github.com/user-attachments/assets/8faf9668-f896-4f68-8e84-2397c1d37db9" />

- 内存分段是基于代码的作用区进行分段，会产生很多内存碎片（属于外部碎片）（随着程序的执行，内存中的空闲区域可能会变得零散），有内存碎片就需要进行内存交换以合并碎片，这样的效率就会很低。内存分页是指虚拟地址和实际地址通过页进行映射，一个程序运行会使用多个整页，会产生内部碎片

- 虚拟内存虽然和物理内存是一一对应的关系，但是并不是所有的虚拟内存都会分配物理内存，只有进程所需要的时候才会进行分配，且还有内存回收的机制，因此虚拟内存一般都是大于物理内存的

- 内存不够时会触发内存回收，直接内存回收（同步），后台内存回收（异步），也可以分为文件页回收（干净页直接释放）和匿名页回收（触发swap机制）
