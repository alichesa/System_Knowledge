# System_Knowledge
- 在X86架构中一般有四个不同的特权级，R0 ~ R3，R0是内核态，R3是用户态，R1和R2一般是驱动程序。用户态一般使用系统调用（Syscall -- read write open 等内核函数）与内核进行交互，一般态的切换中会触发中断。系统调用一般会比普通的函数运行慢，因为它设计上下文的切换，一般是100-200个cpu周期。具体流程是：用户程序调用write() → 触发0x80中断 → CPU保存用户态寄存器 → 切换至内核栈 → 执行sys_write() → 返回用户态前恢复现场

- 用户态申请内存的流程是：应用程序调用malloc → brk/mmap触发 → 内核管理物理内存，具体实现流程 -- 检测申请内存 → 调用相应的函数 → 在进程空间创建虚拟内存区域 → 建立页表映射 → 返回虚拟地址 → 程序首次访问内存触发缺页异常，此时内核分配实际物理内存。其中mmap是大块内存（>256kb）另外一个是小内存。mmap与brk的区别就是mmap使用free会立即释放内存，而brk不会立即释放，只是先将内存标记为缓冲区。频繁使用mmap会不断触发缺页中断，这就导致上下文切换十分频繁；频繁使用brk会导致页的碎片化很严重。brk的碎片是内部碎片，主要是虚假释放的碎片，mmap的碎片是外部碎片，就是一段一段不连续是内存碎片

- 进程是系统资源分配的最小单元，每个进程都有独立的地址空间、堆栈、文件描述符等。线程是程序调度的最小单元，多个线程之间共享内存空间、全局变量等。进程创建的开销是比较大的，因为需要分配独立的资源，需要系统内核负责，也会涉及到上下文的切换，并且还需要进行内存映射，但是线程开销较小，仅设计到寄存器/栈的切换。进程之间的通信有很多 -- 管道、消息队列、共享内存、信号量、套接字。而线程之间的通信 -- 共享内存、条件变量和互斥锁、读写锁  

- 每个线程含有自己的寄存器和局部内存（栈），每个线程块有个共享内存，线程的切换必须保存所有的寄存器，寄存器是CPU组件，栈是内存组件，RSP寄存器指向栈顶

- 查询具有TLB（快表）的话能击大加速，如果没有命中则会去再页表中寻址。TLB一般在CPU缓存中，而页表一般在内存中。若查询的页表映射关系发生变化还可能发生缺页中断（所查找的资源由于其他资源需要进行了内存交换）

- 内存交换是不同进程之间，一般发生在内存不足的情况下，当被交换的内存被再次访问时就会触发缺页中断，然后又将该内存加载回来，内存覆盖是同一个程序之间

- 虚拟技术有时分复用和空分复用，时分复用可以提现在进程交替使用CPU，空分复用体现在虚拟内存的抽象

- 进程同步可以通过互斥锁、信号量、读写锁等进行同步

- 进程通信--管道通信， 消息队列， 共享内存， 信号量， 套接字

- 虚拟内存大小和物理内存大小并不是一一对应的，虚拟内存可以比物理内存大

- 读写锁就是可以同时读，若有人写则不能同时读。互斥锁就类似于排他锁。条件变量。自旋锁就是线程无法取得锁但是也不会立马放弃CPU的时间片，就是一直循环尝试获得锁

- 32和64位主要是cpu一次能处理的数据最大位宽

- 处理速度的顺序：寄存器 -> 缓存 (数据缓存和指令缓存一般分开)-> 内存 -> 硬盘

- cache的单元是cache_line，CPU从内存读取数据并不是直接读，而是一块一块地放入cache中，再读取。因此提升程序运行速度可以从提升指令缓存速度和提升数据缓存速度出发

- CPU缓存的写操作有写直达和写回两个操作，写回比较快的操作，因为它会通过标记cache里面的是否为脏数据从而进行处理

- 为了使得数据读取正确，就有了写传播和串行化两个操作，MESI就是满足这两个的协议

- L1和L2是CPU核自己独享的，L3是共享

- 中断分为硬中断和软中断，软中断一般由内核线程（操作系统所管理和执行的线程）所执行，软中断分类型，可以看哪个软中断次数多就知道系统资源占用在哪了

- 内核架构分为宏内核，微内核和混合内核，linux采用的是宏内核，意思就是说内核的操作权限更大，windows采用的是混合内核

- 虚拟内存是操作系统引入的，每个进程都有自己一套虚拟地址空间，这是单片机所没有的，单片机所指的地址是实际物理地址

- 内存分段是基于代码的作用区进行分段，会产生很多内存碎片，有内存碎片就需要进行内存交换以合并碎片，这样的效率就会很低。内存分页是指虚拟地址和实际地址通过页进行映射，一个程序运行会使用多个整页


- 虚拟内存虽然和物理内存是一一对应的关系，但是并不是所有的虚拟内存都会分配物理内存，只有进程所需要的时候才会进行分配，且还有内存回收的机制，因此虚拟内存一般都是大于物理内存的

- malloc分配的是虚拟内存，此时不会有任何操作，当进程真的需要的时候会出发缺页中断，此时才是进行分配的时候

- 内存不够时会触发内存回收，直接内存回收（同步），后台内存回收（异步），也可以分为文件页回收（干净页直接释放）和匿名页回收（触发swap机制）

- 
